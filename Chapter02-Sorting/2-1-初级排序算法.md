---
title: 2019-01-27-algorithms4-first
tags:
  - 算法
  - 讀書
---

### 2.1 排序算法類模版

```java
public class Example {
    public static void sort(Comparable[] a) {
        // 各類排序算法
    }

    private static boolean less(Comparable v, Comparable w) {
        // 對元素進行比較
        return v.compareTo(w) < 0;
    }

    private static void exch(Comparable[] a, int i, int j) {
        // 將元素交換位置
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    private static void show(Comparable[] a) {
        // 在單行中打印數組
        for(int i = 0; i < a.length; i++)
            StdOut.print(a[i] + " ");
        StdOut.println();
    }

    public static boolean isSorted(Comparable[] a) {
        // 測試數組元素是否有序
        for(int i = 1; i < a.length; i++)
            if(less(a[i], a[i - 1]))
                return false;
        return true;
    }

    public static void main(String[] args) {
        // 從標準輸入讀取字符串，將它們排序並輸出
        String[] a = In.readStrings();
        sort(a);
        assert isSorted(a);
        show(a);
    }
}
```

- sort - 排序算法的具體實現
- less - 比較元素
- exch - 元素交換位置
- show - 打印數組
- isSorted - 判斷數組元素是否有序
- main - 標準輸入讀取字符串，將它們排序並輸出

#### 2.1.2 選擇排序(Selection sort)

```java
public static void sort(Comparable[] a) {
    // 將 a[] 按升序排列
    int N = a.length;
    for(int i = 0 ; i < N; i++) {
        // 將 a[i] 和 a[i...N]中最小的元素交換
        int min = i; // 最小元素的索引
        for(int j = i+1; j < N; j++)
            if(less(a[j], a[min]))
                min = j;
        exch(a, i, min);
    }
}
```

![](https://algs4.cs.princeton.edu/21elementary/images/selection.png)

[**選擇排序**](https://algs4.cs.princeton.edu/21elementary/Selection.java.html)對於長度為 N 的數組，需要大約 N^2/2 次比較和 N 次交換。

選擇排序的特點：

- 運行時間和輸入無關：一個已經有序的數組或是主鍵全部相等的數組和一個元素隨機排列的數組所用的排序時間一樣長；
- 數據移動是最少的：每次交換都會改變兩個數組元素的值，因此選擇排序用了 N 次交換——交換次數和數組的大小是**線性**關係。其他算法大多都是線性對數或是平方級別。

#### 2.1.3 插入排序(Insertion sort)

```java
public static void sort(Comparable[] a) {
    // 將 a[] 按升序排列
    int N = a.length;
    for(int i = 1; i < N; i++) {
        // 將 a[i] 插入到 a[i-1]、a[i-2]、a[i-3]...之中
        /** 有改進空間，見練習 2.1.25 */
        for(int j = i; j > 0 && less(a[j], a[j-1]); j--)
            exch(a, j, j-1);
    }
}
```

![](https://algs4.cs.princeton.edu/21elementary/images/insertion.png)

[**插入排序**](https://algs4.cs.princeton.edu/21elementary/Insertion.java.html)每次將正在遍歷的元素插入到其他已經有序的元素中的適當位置。與選擇排序一樣，當前索引左邊的所有元素都是有序的，但它們的最終位置還不確定。為了給更小的元素騰出空間，它們可能會向右移動。當索引到達數組的右端時，數組排序就完成了。

對於隨機排列的長度為 N 且主鍵不重複的數組，平均情況下插入排序需要 ~N^2/4 次比較以及 ~N^2/4 次交換。最壞情況下需要 ~N^2/2 次比較和 ~N^2/2 次交換，最好情況下需要 N-1 次比較和 0 次交換。

#### 2.1.4 排序算法可視化

![](https://algs4.cs.princeton.edu/21elementary/images/bars.png)

#### 2.1.5 希爾排序(Shellsort)

```java
public static void sort(Comparable[] a) {
    // 將 a[] 按升序排列
    int N = a.length;
    int h = 1;
    while(h < N / 3)
        h = 3 * h + 1; // 1, 4, 13, 40, 121, 364, 1093, ...
    while(h >= 1) {
        // 將數組變為 h 有序
        for(int i = h; i < N; i++) {
            // 將 a[i] 插入到 a[i-h]，a[i-2*h]，a[i-3*h]... 之中
            for(int j = i; j >= h && less(a[j], a[j -h]); j -= h)
                exch(a, j, j-h);
        }
        h /= 3;
    }
}
```

![](https://algs4.cs.princeton.edu/21elementary/images/shell.png)

[**希爾排序**](https://algs4.cs.princeton.edu/21elementary/Shell.java.html)是一種基於插入排序的快速的排序算法，為了加快速度簡單地改進了插入排序，交換不相鄰的元素以對數組的局部進行排序，並最終用插入排序將局部有序的數組排序。

**思想**：使數組中任意間隔為 h 的元素都是有序的。這樣的數組被稱為 **h 有序數組**。換句話說，一個 h 有序數組就是 h 個互相獨立的有序數組編織在一起的一個數組。

![](https://algs4.cs.princeton.edu/21elementary/images/h-sorted.png)