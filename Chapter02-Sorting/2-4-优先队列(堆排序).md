### 2.4 優先隊列(Priority queues)

優先隊列最重要的操作就是**插入元素**和**刪除最大元素**。

**應用場景：**在某些數據處理的場合，**總數據量太大**（可以認為輸入是無限的），無法排序（甚至無法全部裝進內存）。如果將每個新的輸入和已知的 M 個最大（或最小）元素比較，除非 M 較小，否則這種比較的代價會非常高昂。如果有了**優先隊列**，就只用一個能存儲 M 個元素的隊列即可。

#### 2.4.1 API

優先級隊列的特徵在於刪除最大值和插入操作。按照慣例，我們將僅使用 less() 方法比較鍵值，就像我們一直在進行排序一樣。因此，如果記錄可以有重複的鍵，則 maximum 表示最大鍵值之一。要完成 API，我們還需要構造函數和測試是否為空操作。為了靈活性，我們使用通用類型 Key 實現 Comparable 的通用實現。

![](https://algs4.cs.princeton.edu/24pq/images/pq-api.png)

### 2.4.2 初級實現

- 數組實現（無序）：惰性方法，僅在必要的時候找出最大元素；
- 數組實現（有序）：積極方法：在插入時就保持列表有序，使後續操作更高效；
- 鍊錶表示法

![](https://algs4.cs.princeton.edu/24pq/images/pq-array.png)

在上述優先隊列的初級實現中，**刪除最大元素**和**插入元素**這兩個操作之一在最壞情況下需要**線性**時間來完成。

| 數據結構 | 插入元素 | 刪除最大元素 |
| :------: | :------: | :----------: |
| 有序數組 | N | 1 |
| 無序數組 | 1 | N |
| 堆 | logN | logN |
| 理想情況 | 1 | 1 |

#### 2.4.3 堆的定義

當一棵二叉樹的每個結點都**大於等於**它的兩個子結點時，它被稱為**堆有序**。

根結點是堆有序的二叉樹中的最大結點。

##### 二叉堆表示法

如果使用指針來表示堆有序的二叉樹，那麼每個元素都需要**三個指針**來找到它的上下結點。

但使用完全二叉樹，只需要數組而不需要指針就可以表示，十分方便。具體方法是將二叉樹的結點按照**層級順序**放入數組中。

![](https://algs4.cs.princeton.edu/24pq/images/heap.png)

**定義**：**二叉堆**（後文簡稱為堆）是一組能夠用堆有序的完全二叉樹排序的元素，並在數組中按照層級儲存（不使用數組的第一個位置）。

![](https://algs4.cs.princeton.edu/24pq/images/heap-representations.png)

在一個堆中，位置`k`的結點的父結點的位置為`⌊k/2⌋`，子結點位置分別為`2k`和`2k+1`。

**高性能的原因**：利用在數組中無需指針即可沿樹上下移動的便利。

> 注：完全二叉樹：除最後一層外，每一層上的結點數均達到最大值；在最後一層上只缺少右邊的若干結點。
>
> 一棵大小為 N 的完全二叉樹的高度為`⌊lgN⌋`。
>

#### 2.4.4 堆的算法

我們在長度為*n* + 1 的私有數組`pq []`中表示大小為*N* 的堆，其中`pq [0]`未使用且堆在`pq [1]`到`pq [n ]中`。我們只通過函數`less()` 和`exch()`來訪問元素。

**堆的有序化**：打破堆的狀態，然後再遍歷堆並按照要求將堆的狀態恢復。

##### 2.4.4.1 由下至上的堆序列化（上浮）

```java
private void swim（int k）{
   while（k> 1 && less（k / 2，k））{
      exch（k，k / 2）;
      k = k / 2;
   }
}
```

![](https://algs4.cs.princeton.edu/24pq/images/sink.png)

##### 2.4.4.2 由上至下的堆序列化（下沉）

```java
private void sink（int k）{
   while（2 * k <= N）{
      int j = 2 * k;
      if（j <N && less（j，j + 1））j ++;
      if（！less（k，j））break;
      exch（k，j）;
      k = j;
   }
}
```

![](https://algs4.cs.princeton.edu/24pq/images/sink.png)

**插入元素**時，將新元素加到數組末尾，增加堆的大小並讓這個新元素上浮到合適的位置。

**刪除最大元素**時，從數組頂端刪去最大的元素並將數組的最後一個元素放到頂端，減小堆的大小並讓這個元素下沉到合適的位置。

![](https://algs4.cs.princeton.edu/24pq/images/heap-ops.png)

這樣，**刪除最大元素**和**插入元素**這兩個操作的用時和隊列的大小僅成**對數**關係。對於一個含有 N 個元素的基於堆的優先隊列，插入元素操作只需不超過 (lgN+1) 次比較，刪除最大元素的操作需要不超過 2lgN 次比較。

**基於堆的優先隊列：**

詳情請看：[MaxPQ.java](https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html) 和[MinPQ.java中實現](https://algs4.cs.princeton.edu /24pq/MinPQ.java.html)

![](https://algs4.cs.princeton.edu/24pq/images/heap-pq.png)

#### 2.4.5 堆排序


```
    private static void sink(Comparable[] pq, int k, int n) {
        while (2*k <= n) {
            int j = 2*k;
            if (j < n && less(pq, j, j+1)) j++;
            if (!less(pq, k, j)) break;
            exch(pq, k, j);
            k = j;
        }
    }


```
> for循環構造了堆，然後while循環將最大的元素 a[1] 和 a[N] 交換並恢復了堆，如此重複知道堆變空。將 exch() 和 less() 實現中的索引減一即可得到和其他排序算法一致的實現（將 a[0] 至 a[N-1] 排序）。

![堆排序具體流程示意圖](https://algs4.cs.princeton.edu/24pq/images/heapsort-trace.png)
![堆排序的軌跡-每次下沉後的數組內容](https://algs4.cs.princeton.edu/24pq/images/heapsort.png)

##### 2.4.5.2 下沉排序
堆排序的主要工作都是在第二階段完成。這裡我們將堆中的最大元素刪除，然後放入堆縮小後數組中空出的位置。這個過程和選擇排序有些類似（按照降序而非升序取出所有的元素），但所需的比較要少很多，因為堆提供了一種從未排序部分找到最大元素的有效方法。