### 2.3 快速排序

**特點：**

- 原地排序（只需要一個很小的輔助棧）；
- 將長度為 N 的數組排序所需的時間和 NlgN 成正比。

#### 2.3.1 基本算法

快速排序是一種分治的排序算法。它的工作原理是將一個數組分成兩部分，通過**切分**實現某一部分總小於另一數組，然後分別獨立排序。

![](https://algs4.cs.princeton.edu/23quicksort/images/quicksort-overview.png)



**切分**：一般策略是先隨意地選取a[lo] 作為**切分元素**，即那個會被排定的元素，然後我們從數組的左端開始向右掃描直到找到一個* *大於等於**它的元素，再從數組的右端開始向左掃描直到找到一個小於等於它的元素。這兩個元素顯然是沒有排定的，因此我們交換它們的位置。

如此繼續，我們就可以保證左指針 i 的左側元素都不大於切分元素，右指針 j 的右側元素都不小於切分元素。當兩個指針相遇時，我們只需要將切分元素 a[lo] 和左子數組最右側的元素（a[j]）交換然後返回 j 即可。

```java
private static int partition(Comparable[] a, int lo, int hi) {
    int i = lo;
    int j = hi + 1; // 左右掃描指針
    // 切分元素
    Comparable v = a[lo];
    while (true) {

        // find item on lo to swap
        while (less(a[++i], v)) {
            if (i == hi) break;
        }

        // find item on hi to swap
        while (less(v, a[--j])) {
            if (j == lo) break; // redundant since a[lo] acts as sentinel
        }

        // check if pointers cross
        if (i >= j) break;

        exch(a, i, j);
    }

    // put partitioning item v at a[j]
    exch(a, lo, j);

    // now, a[lo .. j-1] <= a[j] <= a[j+1 .. hi]
    return j;
}
```
> 這段代碼按照 a[lo] 的值 v 進行切分。當指針 i 和 j 相遇時主循環退出。在循環中，a[i]小於v 時我們增大i，a[j] 大於v 時我們減小j，然後交換a[i] 和a[j] 來保證i 左側的元素都不大於v ，j 右側的元素都不小於v。當指針相遇時交換 a[lo] 和 a[j]，切分結束（這樣切分值就留在 a[j] 中）。

![](https://algs4.cs.princeton.edu/23quicksort/images/partitioning-overview.png)

![](https://algs4.cs.princeton.edu/23quicksort/images/partitioning.png)

```java
public class Quick {
    // This class should not be instantiated.
    private Quick() { }

    public static void sort(Comparable[] a) {
        StdRandom.shuffle(a); // 消除對輸入的依賴
        sort(a, 0, a.length - 1);
        assert isSorted(a);
    }

    // quicksort the subarray from a[lo] to a[hi]
    private static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return;
        int j = partition(a, lo, hi); // 切分
        sort(a, lo, j-1); // 左半部分排序
        sort(a, j+1, hi); // 右半部分排序
    }
}
```

遞歸的將字數組 a[lo..hi] 排序，先用 partition() 方法將 a[j] 放到一個合適的位置，然後再用遞歸將其他位置的元素排序。

#### 2.3.2 性能特點

快速排序的兩個速度優勢：

1. 切分方法的內循環會用一個遞增的索引將數組元素和一個定值比較，而歸併排序、希爾排序等還在內循環中移動數據；
2. 比較次數少。

將長度為 N 的無重複數組排序，快速排序平均需要 ~2NlnN 次比較（以及 1/6 的交換）。