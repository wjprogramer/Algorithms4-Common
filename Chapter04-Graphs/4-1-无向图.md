### 4.1 無向圖

#### 4.1.1 定義

![](https://algs4.cs.princeton.edu/41graph/images/graph-anatomy.png)

![](https://algs4.cs.princeton.edu/41graph/images/tree.png)

![](https://algs4.cs.princeton.edu/41graph/images/forest.png)

#### 4.1.2 表示無向圖的數據類型

**無向圖API：**

![](https://algs4.cs.princeton.edu/41graph/images/graph-api.png)

方法 `adj()` 返回與給定頂點相鄰的所有頂點。

下面代碼為常用的圖處理代碼：

```java
public class GraphClient {
  // 最大度
  public static int maxDegree(Graph G) {
      int max = 0;
      for (int v = 0; v < G.V(); v++)
          if (G.degree(v) > max)
              max = G.degree(v);
      return max;
  }

  // 平均度
  public static int avgDegree(Graph G) {
      // each edge incident on two vertices
      return 2 * G.E() / G.V();
  }

  // 循環數
  public static int numberOfSelfLoops(Graph G) {
      int count = 0;
      for (int v = 0; v < G.V(); v++)
          for (int w : G.adj(v))
              if (v == w) count++;
      return count/2; // self loop appears in adjacency list twice
  }

  public static void main(String[] args) {
      In in = new In(args[0]);
      Graph G = new Graph(in);
      StdOut.println(G);

      StdOut.println("vertex of maximum degree = " + maxDegree(G));
      StdOut.println("average degree = " + avgDegree(G));
      StdOut.println("number of self loops = " + numberOfSelfLoops(G));
  }
}
```

圖常用表示法：鄰接矩陣、邊的數組、**鄰接表數組**

![](https://algs4.cs.princeton.edu/41graph/images/adjacency-lists.png)

##### 4.1.2.2 鄰接表的數據結構

將每個點的所有相鄰頂點都保存在該頂點對應的元素所指向的一張鍊錶中，如上圖展示。

```java
public class Graph {
    private static final String NEWLINE = System.getProperty("line.separator");

    private final int V;
    private int E;
    private Bag<Integer>[] adj;
    
    public Graph(int V) {
        if (V < 0) throw new IllegalArgumentException("Number of vertices must be nonnegative");
        this.V = V;
        this.E = 0;
        adj = (Bag<Integer>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<Integer>();
        }
    }

    public Graph(In in) {
        try {
            this.V = in.readInt();
            if (V < 0) throw new IllegalArgumentException("number of vertices in a Graph must be nonnegative");
            adj = (Bag<Integer>[]) new Bag[V];
            for (int v = 0; v < V; v++) {
                adj[v] = new Bag<Integer>();
            }
            int E = in.readInt();
            if (E < 0) throw new IllegalArgumentException("number of edges in a Graph must be nonnegative");
            for (int i = 0; i < E; i++) {
                int v = in.readInt();
                int w = in.readInt();
                validateVertex(v);
                validateVertex(w);
                addEdge(v, w);
            }
        }
        catch (NoSuchElementException e) {
            throw new IllegalArgumentException("invalid input format in Graph constructor", e);
        }
    }
    
    public Graph(Graph G) {
        this(G.V());
        this.E = G.E();
        for (int v = 0; v < G.V(); v++) {
            // reverse so that adjacency list is in same order as original
            Stack<Integer> reverse = new Stack<Integer>();
            for (int w : G.adj[v]) {
                reverse.push(w);
            }
            for (int w : reverse) {
                adj[v].add(w);
            }
        }
    }

    public int V() {
        return V;
    }

    public int E() {
        return E;
    }

    private void validateVertex(int v) {
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    public void addEdge(int v, int w) {
        validateVertex(v);
        validateVertex(w);
        E++;
        adj[v].add(w);
        adj[w].add(v);
    }

    public Iterable<Integer> adj(int v) {
        validateVertex(v);
        return adj[v];
    }
}
```

完整代碼：[Graph.java](https://algs4.cs.princeton.edu/41graph/Graph.java.html)

Bag 類：[Bag.java](https://algs4.cs.princeton.edu/13stacks/Bag.java.html)

#### 4.1.3 深度優先搜索

深度優先搜索是一種經典的遞歸方法，用於系統地檢查圖中的每個頂點和邊。訪問一個頂點：

- 將其標記為已訪問過。
- 訪問（遞歸地）與其相鄰且尚未標記的所有頂點。

![](https://algs4.cs.princeton.edu/41graph/images/search-api.png)

```java
public class DepthFirstSearch {
    private boolean[] marked; // marked[v] = is there an s-v path?
    private int count; // number of vertices connected to s

    public DepthFirstSearch(Graph G, int s) {
        marked = new boolean[G.V()];
        validateVertex(s);
        dfs(G, s);
    }

    // depth first search from v
    private void dfs(Graph G, int v) {
        count++;
        marked[v] = true;
        for (int w : G.adj(v)) {
            if (!marked[w]) {
                dfs(G, w);
            }
        }
    }

    public boolean marked(int v) {
        validateVertex(v);
        return marked[v];
    }

}
```

完整代碼：[DepthFirstSearch.java](https://algs4.cs.princeton.edu/41graph/DepthFirstSearch.java.html)

#### 4.1.4 尋找路徑

修改深度優先搜索，不僅要確定兩個給定頂點之間是否存在路徑，還要找到這樣的路徑（如果存在）。

**以下API：**

![](![Paths API](https://algs4.cs.princeton.edu/41graph/images/paths-api.png))

我們通過將 edgeTo[w] 設置為 v 來記住第一次將我們帶到每個頂點 w 的邊 v-w 。換句話說，v-w 是從 s 到 w 的已知路徑上的最後一條邊。搜索結果是一棵植根於源頭的樹; edgeTo[] 是該樹的父鏈接表示。

```java
public class DepthFirstPaths {
    private boolean[] marked; // marked[v] = is there an s-v path?
    private int[] edgeTo; // edgeTo[v] = last edge on s-v path
    private final int s; // source vertex

    public DepthFirstPaths(Graph G, int s) {
        this.s = s;
        edgeTo = new int[G.V()];
        marked = new boolean[G.V()];
        validateVertex(s);
        dfs(G, s);
    }

    // depth first search from v
    private void dfs(Graph G, int v) {
        marked[v] = true;
        for (int w : G.adj(v)) {
            if (!marked[w]) {
                edgeTo[w] = v;
                dfs(G, w);
            }
        }
    }

    public boolean hasPathTo(int v) {
        validateVertex(v);
        return marked[v];
    }
    
    public Iterable<Integer> pathTo(int v) {
        validateVertex(v);
        if (!hasPathTo(v)) return null;
        Stack<Integer> path = new Stack<Integer>();
        for (int x = v; x != s; x = edgeTo[x])
            path.push(x);
        path.push(s);
        return path;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }
}
```

 完整代碼： [DepthFirstPaths.java](https://algs4.cs.princeton.edu/41graph/DepthFirstPaths.java.html)

#### 4.1.5 廣度優先搜索

廣度優先搜索。深度優先搜索找到從源頂點到目標頂點 v 的一些路徑。我們通常需要的是找到最短的路徑（具有最小邊數的路徑）。廣度優先搜索是基於此目標的經典方法。為了找到從s 到v 的最短路徑，我們從s 開始並找我們可以通過一條邊就能到達的所有頂點中的v，然後我們再通過兩條邊來檢查我們可以從s 到達的所有頂點中的v ..... 以此下去。

為了實現這個策略，我們建立一個已標記但尚未檢查其鄰接列表的所有頂點的隊列。我們將源頂點放在隊列中，然後執行以下步驟直到隊列為空：

- 從隊列中刪除下一個頂點 v。
- 將與 v 相鄰的所有未標記頂點放入隊列並標記它們。

```java
public class BreadthFirstPaths {
    private static final int INFINITY = Integer.MAX_VALUE;
    private boolean[] marked; // marked[v] = is there an s-v path
    private int[] edgeTo; // edgeTo[v] = previous edge on shortest s-v path
    private int[] distTo; // distTo[v] = number of edges shortest s-v path

    public BreadthFirstPaths(Graph G, int s) {
        marked = new boolean[G.V()];
        distTo = new int[G.V()];
        edgeTo = new int[G.V()];
        validateVertex(s);
        bfs(G, s);

        assert check(G, s);
    }

    // breadth-first search from a single source
    private void bfs(Graph G, int s) {
        Queue<Integer> q = new Queue<Integer>();
        for (int v = 0; v < G.V(); v++)
            distTo[v] = INFINITY;
        distTo[s] = 0;
        marked[s] = true;
        q.enqueue(s);

        while (!q.isEmpty()) {
            int v = q.dequeue();
            for (int w : G.adj(v)) {
                if (!marked[w]) {
                    edgeTo[w] = v;
                    distTo[w] = distTo[v] + 1;
                    marked[w] = true;
                    q.enqueue(w);
                }
            }
        }
    }

    public boolean hasPathTo(int v) {
        validateVertex(v);
        return marked[v];
    }

    public Iterable<Integer> pathTo(int v) {
        validateVertex(v);
        if (!hasPathTo(v)) return null;
        Stack<Integer> path = new Stack<Integer>();
        int x;
        for (x = v; distTo[x] != 0; x = edgeTo[x])
            path.push(x);
        path.push(x);
        return path;
    }
}
```

完整代碼：[BreadthFirstPaths.java](https://algs4.cs.princeton.edu/41graph/BreadthFirstPaths.java.html)

#### 4.1.6 連通分量

深度優先搜索的下一個直接應用是查找圖的連通分量。 **定義以下API：**

![](https://algs4.cs.princeton.edu/41graph/images/cc-api.png)

```java
public class CC {
    private boolean[] marked;   // marked[v] = has vertex v been marked?
    private int[] id;           // id[v] = id of connected component containing v
    private int[] size;         // size[id] = number of vertices in given component
    private int count;          // number of connected components

    /**
     * Computes the connected components of the undirected graph {@code G}.
     *
     * @param G the undirected graph
     */
    public CC(Graph G) {
        marked = new boolean[G.V()];
        id = new int[G.V()];
        size = new int[G.V()];
        for (int v = 0; v < G.V(); v++) {
            if (!marked[v]) {
                dfs(G, v);
                count++;
            }
        }
    }

    // depth-first search for a Graph
    private void dfs(Graph G, int v) {
        marked[v] = true;
        id[v] = count;
        size[count]++;
        for (int w : G.adj(v)) {
            if (!marked[w]) {
                dfs(G, w);
            }
        }
    }

    public int id(int v) {
        validateVertex(v);
        return id[v];
    }

    public int size(int v) {
        validateVertex(v);
        return size[id[v]];
    }

    public int count() {
        return count;
    }

    public boolean connected(int v, int w) {
        validateVertex(v);
        validateVertex(w);
        return id(v) == id(w);
    }
}
```

完整代碼：[CC.java](https://algs4.cs.princeton.edu/41graph/CC.java.html)

