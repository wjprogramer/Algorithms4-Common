### 4.2 有向圖

#### 4.2.1 術語定義

![](https://algs4.cs.princeton.edu/42digraph/images/digraph-anatomy.png)

#### 4.2.2 有向圖的數據類型

**API：**

![](https://algs4.cs.princeton.edu/42digraph/images/digraph-api.png)

方法`adj()`允許代碼迭代從給定頂點相鄰的頂點。

**數據表示：**

![](https://algs4.cs.princeton.edu/42digraph/images/digraph-input.png)

我們使用鄰接列表表示，其中我們定義由邊連接到每個頂點的頂點列表的頂點索引數組。

![](https://algs4.cs.princeton.edu/42digraph/images/adjacency-lists.png)

**代碼實現：**

```java
public class Digraph {
    private static final String NEWLINE = System.getProperty("line.separator");

    private final int V; // number of vertices in this digraph
    private int E; // number of edges in this digraph
    private Bag<Integer>[] adj; // adj[v] = adjacency list for vertex v
    private int[] indegree; // indegree[v] = indegree of vertex v
    
    public Digraph(int V) {
        if (V < 0) throw new IllegalArgumentException("Number of vertices in a Digraph must be nonnegative");
        this.V = V;
        this.E = 0;
        indegree = new int[V];
        adj = (Bag<Integer>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<Integer>();
        }
    }

    public void addEdge(int v, int w) {
        validateVertex(v);
        validateVertex(w);
        adj[v].add(w);
        indegree[w]++;
        E++;
    }

    public Digraph reverse() {
        Digraph reverse = new Digraph(V);
        for (int v = 0; v < V; v++) {
            for (int w : adj(v)) {
                reverse.addEdge(w, v);
            }
        }
        return reverse;
    }
}

```

完整代碼：[Digraph.java](https://algs4.cs.princeton.edu/42digraph/Digraph.java.html)

#### 4.2.3 有向圖的可達性

- 單點可達性：給定有向圖和源 s ，是否存在從s到v的有向路徑？如果是這樣，找到這樣的路徑。 [DirectedDFS.java](https://algs4.cs.princeton.edu/42digraph/DirectedDFS.java.html) 使用深度優先搜索來解決此問題。

  ```java
  public class DirectedDFS {
      private boolean[] marked; // marked[v] = true iff v is reachable from source(s)
      private int count; // number of vertices reachable from source(s)
      
      public DirectedDFS(Digraph G, int s) {
          marked = new boolean[G.V()];
          validateVertex(s);
          dfs(G, s);
      }
  
      public DirectedDFS(Digraph G, Iterable<Integer> sources) {
          marked = new boolean[G.V()];
          validateVertices(sources);
          for (int v : sources) {
              if (!marked[v]) dfs(G, v);
          }
      }
  
      private void dfs(Digraph G, int v) {
          count++;
          marked[v] = true;
          for (int w : G.adj(v)) {
              if (!marked[w]) dfs(G, w);
          }
      }
  
      public boolean marked(int v) {
          validateVertex(v);
          return marked[v];
      }
  
      public static void main(String[] args) {
  
          // read in digraph from command-line argument
          In in = new In(args[0]);
          Digraph G = new Digraph(in);
  
          // read in sources from command-line arguments
          Bag<Integer> sources = new Bag<Integer>();
          for (int i = 1; i < args.length; i++) {
              int s = Integer.parseInt(args[i]);
              sources.add(s);
          }
  
          // multiple-source reachability
          DirectedDFS dfs = new DirectedDFS(G, sources);
  
          // print out vertices reachable from sources
          for (int v = 0; v < G.V(); v++) {
              if (dfs.marked(v)) StdOut.print(v + " ");
          }
          StdOut.println();
      }
  }
  ```

  

- 多點可達性：給定有向圖和一組源頂點，是否存在從集合中的任何頂點到v的有向路徑？ [DepthFirstDirectedPaths.java](https://algs4.cs.princeton.edu/42digraph/DepthFirstDirectedPaths.java.html) 使用深度優先搜索來解決此問題。

  可用於 java 程序中的 標記 - 清除的垃圾收集算法。標記－清除的垃圾回收策略會對每個對象保留一個位做垃圾收集之用。它會**週期性地運行一個類似於DirectedDFS 的有向圖可達性算法**來標記所有**可以被訪問到**的對象，然後清理所有對象，回收**沒有被標記**的對象，以騰出內存供新的對象使用。

- 單點有向路徑：給定有向圖和源 s，是否存在從 s 到 v 的有向路徑？如果是這樣，找到這樣的路徑。 [DepthFirstDirectedPaths.java](https://algs4.cs.princeton.edu/42digraph/DepthFirstDirectedPaths.java.html) 使用深度優先搜索來解決此問題。

- 單點最短有向路徑：給定有向圖和源 s，是否存在從 s 到 v 的有向路徑？如果是這樣，找到最短的路徑。 [BreadthFirstDirectedPaths.java](https://algs4.cs.princeton.edu/42digraph/BreadthFirstDirectedPaths.java.html) 使用廣度優先搜索來解決此問題。

#### 4.2.4 環和有向無環圖

有向環在涉及處理有向圖的應用程序中特別重要。

- 判斷有向圖中是否有壞？有向環檢測：給定的有向圖是否有有向環？如果是這樣，找到這樣一個循環。 [DirectedCycle.java](https://algs4.cs.princeton.edu/42digraph/DirectedCycle.java.html) 使用深度優先搜索解決了這個問題。

  ![image-20190210144554271](assets/image-20190210144554271.png)

  ```java
  public class DirectedCycle {
      private boolean[] marked;        // marked[v] = has vertex v been marked?
      private int[] edgeTo;            // edgeTo[v] = previous vertex on path to v
      private boolean[] onStack;       // onStack[v] = is vertex on the stack?
      private Stack<Integer> cycle;    // directed cycle (or null if no such cycle)
  
      public DirectedCycle(Digraph G) {
          marked  = new boolean[G.V()];
          onStack = new boolean[G.V()];
          edgeTo  = new int[G.V()];
          for (int v = 0; v < G.V(); v++)
              if (!marked[v] && cycle == null) dfs(G, v);
      }
  
      private void dfs(Digraph G, int v) {
          onStack[v] = true;
          marked[v] = true;
          for (int w : G.adj(v)) {
  
              // short circuit if directed cycle found
              if (cycle != null) return;
  
              // found new vertex, so recur
              else if (!marked[w]) {
                  edgeTo[w] = v;
                  dfs(G, w);
              }
  
              // trace back directed cycle
              else if (onStack[w]) {
                  cycle = new Stack<Integer>();
                  for (int x = v; x != w; x = edgeTo[x]) {
                      cycle.push(x);
                  }
                  cycle.push(w);
                  cycle.push(v);
                  assert check();
              }
          }
          onStack[v] = false;
      }
  }
  ```
- 頂點的深度優先次序與拓撲排序

  深度優先搜索搜索只訪問每個頂點一次。典型應用中頂點的三種排列順序：

  - 前序：在遞歸調用之前將頂點加入隊列。
  - 後序：在遞歸調用之後將頂點加入隊列。
  - **逆後序**：在遞歸調用之**後**將頂點壓入**棧**。

  ![](https://algs4.cs.princeton.edu/42digraph/images/dag.png)

  ![](https://algs4.cs.princeton.edu/42digraph/images/depth-first-orders.png)

  ```java
  public class DepthFirstOrder {
      private boolean[] marked; // marked[v] = has v been marked in dfs?
      private int[] pre; // pre[v] = preorder number of v
      private int[] post; // post[v] = postorder number of v
      private Queue<Integer> preorder; // vertices in preorder
      private Queue<Integer> postorder; // vertices in postorder
      private int preCounter; // counter or preorder numbering
      private int postCounter; // counter for postorder numbering
  
      public DepthFirstOrder(Digraph G) {
          pre = new int[G.V()];
          post = new int[G.V()];
          postorder = new Queue<Integer>();
          preorder = new Queue<Integer>();
          marked = new boolean[G.V()];
          for (int v = 0; v < G.V(); v++)
              if (!marked[v]) dfs(G, v);
  
          assert check();
      }
  
      public DepthFirstOrder(EdgeWeightedDigraph G) {
          pre = new int[G.V()];
          post = new int[G.V()];
          postorder = new Queue<Integer>();
          preorder = new Queue<Integer>();
          marked = new boolean[G.V()];
          for (int v = 0; v < G.V(); v++)
              if (!marked[v]) dfs(G, v);
      }
  
      private void dfs(Digraph G, int v) {
          marked[v] = true;
          pre[v] = preCounter++;
          preorder.enqueue(v);
          for (int w : G.adj(v)) {
              if (!marked[w]) {
                  dfs(G, w);
              }
          }
          postorder.enqueue(v);
          post[v] = postCounter++;
      }
  
      private void dfs(EdgeWeightedDigraph G, int v) {
          marked[v] = true;
          pre[v] = preCounter++;
          preorder.enqueue(v);
          for (DirectedEdge e : G.adj(v)) {
              int w = e.to();
              if (!marked[w]) {
                  dfs(G, w);
              }
          }
          postorder.enqueue(v);
          post[v] = postCounter++;
      }
  
      public int pre(int v) {
          validateVertex(v);
          return pre[v];
      }
  
      public int post(int v) {
          validateVertex(v);
          return post[v];
      }
  
      public Iterable<Integer> post() {
          return postorder;
      }
  
      public Iterable<Integer> pre() {
          return preorder;
      }
  
      public Iterable<Integer> reversePost() {
          Stack<Integer> reverse = new Stack<Integer>();
          for (int v : postorder)
              reverse.push(v);
          return reverse;
      }
  }
  ```

  完整代碼：[DepthFirstOrder.java](https://algs4.cs.princeton.edu/42digraph/DepthFirstOrder.java.html)

- 拓撲排序

  - 當且僅當一幅有向圖是無環圖時才能進行拓撲排序。
  - 一幅有向無環圖的拓撲順序即為所有頂點的**逆後序排列**（證明見 p376）。

  ```java
  public class Topological {
      private Iterable<Integer> order; // topological order
      private int[] rank; // rank[v] = rank of vertex v in order
  
      public Topological(Digraph G) {
          DirectedCycle finder = new DirectedCycle(G);
          if (!finder.hasCycle()) {
              DepthFirstOrder dfs = new DepthFirstOrder(G);
              order = dfs.reversePost();
              rank = new int[G.V()];
              int i = 0;
              for (int v : order)
                  rank[v] = i++;
          }
      }
  
      public Topological(EdgeWeightedDigraph G) {
          EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(G);
          if (!finder.hasCycle()) {
              DepthFirstOrder dfs = new DepthFirstOrder(G);
              order = dfs.reversePost();
          }
      }
  
      public Iterable<Integer> order() {
          return order;
      }
  
      public static void main(String[] args) {
          String filename = args[0];
          String delimiter = args[1];
          SymbolDigraph sg = new SymbolDigraph(filename, delimiter);
          Topological topological = new Topological(sg.digraph());
          for (int v : topological.order()) {
              StdOut.println(sg.nameOf(v));
          }
      }
  
  }
  ```

  完整代碼： [Topological.java](https://algs4.cs.princeton.edu/42digraph/Topological.java.html)

#####



