### 平衡查找樹

前幾種算法在最壞情況下的性能還是很糟糕。本節中介紹一種二分查找樹並能保證無論如何構造它，它的運行時間都是對數級別的。

理想情況下，我們希望能夠保持二分查找樹的平衡性，以使樹高為 ~lgN，這樣就能保證所有查找都能在 ~lgN 次比較內結束。

#### 3.3.1 2-3查找樹

為了保持平衡性，2-3 查找樹引入了 2- 節點和 3- 節點，目的是為了讓樹平衡。一顆完美平衡的 2-3 查找樹的所有空鏈接到根節點的距離應該是相同的。

![](https://algs4.cs.princeton.edu/33balanced/images/23tree-anatomy.png)

##### 3.3.1.1 查找

![](https://algs4.cs.princeton.edu/33balanced/images/23tree-search.png)

##### 3.3.1.2 插入

插入操作和 BST 的插入操作有很大區別，BST 的插入操作是先進行一次未命中的查找，然後再將節點插入到對應的空鏈接上。但是 2-3 查找樹如果也這麼做的話，那麼就會破壞了平衡性。它是將新節點插入到葉子節點上。

根據葉子節點的類型不同，有不同的處理方式：

- 如果插入到 2- 節點上，那麼直接將新節點和原來的節點組成 3- 節點即可。

  ![](https://algs4.cs.princeton.edu/33balanced/images/23tree-insert2.png)

- 如果是插入到 3- 節點上，就會產生一個臨時 4- 節點時，需要將 4- 節點分裂成 3 個 2- 節點，並將中間的 2- 節點移到上層節點中。如果上移操作繼續產生臨時 4- 節點則一直進行分裂上移，直到不存在臨時 4- 節點。

  ![](https://algs4.cs.princeton.edu/33balanced/images/23tree-insert3a.png)

##### 3.3.1.3性質

2-3 查找樹插入操作的變換都是局部的，除了相關的節點和鏈接之外不必修改或者檢查樹的其它部分，而這些局部變換不會影響樹的全局有序性和平衡性。

2-3 查找樹的查找和插入操作複雜度和插入順序無關，在最壞的情況下查找和插入操作訪問的節點必然不超過logN 個，含有10 億個節點的2-3 查找樹最多只需要訪問30 個節點就能進行任意的查找和插入操作。

#### 3.3.2 紅黑二叉查找樹

紅黑樹是 2-3 查找樹，但它不需要分別定義 2- 節點和 3- 節點，而是在普通的二叉查找樹之上，為節點添加顏色。指向一個節點的鏈接顏色如果為紅色，那麼這個節點和上層節點表示的是一個 3- 節點，而黑色則是普通鏈接。

![](https://algs4.cs.princeton.edu/33balanced/images/redblack-encoding.png)

紅黑樹具有以下性質：

- 紅鏈接都為左鏈接；
- 完美黑色平衡，即任意空鏈接到根節點的路徑上的黑鏈接數量相同。

畫紅黑樹時可以將紅鏈接畫平。

![](https://algs4.cs.princeton.edu/33balanced/images/redblack-1-1.png)

```java
public class RedBlackBST<Key extends Comparable<Key>, Value> extends BST<Key, Value> {

    private static final boolean RED = true;
    private static final boolean BLACK = false;

    private boolean isRed(Node x) {
        if (x == null)
            return false;
        return x.color == RED;
    }
}
```

#### 3.3.2.1 左旋轉

因為合法的紅鏈接都為左鏈接，如果出現右鏈接為紅鏈接，那麼就需要進行左旋轉操作。

![](https://algs4.cs.princeton.edu/33balanced/images/redblack-left-rotate.png)

```java
public Node rotateRight(Node h) {
    Node x = h.left;
    h.left = x.right;
    x.color = h.color;
    h.color = RED;
    x.N = h.N;
    recalculateSize(h);
    return x;
}
```

右旋轉同理：

![](https://algs4.cs.princeton.edu/33balanced/images/redblack-right-rotate.png)

#### 3.3.3 插入

先將一個節點按二叉查找樹的方法插入到正確位置，然後再進行如下顏色操作：

- 如果右子節點是紅色的而左子節點是黑色的，進行左旋轉；
- 如果左子節點是紅色的，而且左子節點的左子節點也是紅色的，進行右旋轉；
- 如果左右子節點均為紅色的，進行顏色轉換。

```java
@Override
public void put(Key key, Value value) {
    root = put(root, key, value);
    root.color = BLACK;
}

private Node put(Node x, Key key, Value value) {
    if (x == null) {
        Node node = new Node(key, value, 1);
        node.color = RED;
        return node;
    }
    int cmp = key.compareTo(x.key);
    if (cmp == 0)
        x.val = value;
    else if (cmp < 0)
        x.left = put(x.left, key, value);
    else
        x.right = put(x.right, key, value);

    if (isRed(x.right) && !isRed(x.left))
        x = rotateLeft(x);
    if (isRed(x.left) && isRed(x.left.left))
        x = rotateRight(x);
    if (isRed(x.left) && isRed(x.right))
        flipColors(x);

    recalculateSize(x);
    return x;
}
```

可以看到該插入操作和二叉查找樹的插入操作類似，只是在最後加入了旋轉和顏色變換操作即可。

根節點一定為黑色，因為根節點沒有上層節點，也就沒有上層節點的左鏈接指向根節點。 flipColors() 有可能會使得根節點的顏色變為紅色，每當根節點由紅色變成黑色時樹的黑鏈接高度加 1.

![](https://algs4.cs.princeton.edu/33balanced/images/redblack-construction.png)

#### 3.3.4 分析

一顆大小為 N 的紅黑樹的高度不會超過 2logN。最壞的情況下是它所對應的 2-3 樹，構成最左邊的路徑節點全部都是 3- 節點而其餘都是 2- 節點。

紅黑樹大多數的操作所需要的時間都是對數級別的。