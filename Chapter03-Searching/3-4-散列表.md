### 3.4 散列表

散列表類似於數組，可以把散列表的散列值看成數組的索引值。訪問散列表和訪問數組元素一樣快速，它可以在常數時間內實現查找和插入操作。

由於無法通過散列值知道鍵的大小關係，因此散列表無法實現有序性操作。

![](https://algs4.cs.princeton.edu/34hash/images/hashing-crux.png)

#### 3.4.1 散列函數

![](https://algs4.cs.princeton.edu/34hash/images/modular-hashing.png)

對於一個大小為 M 的散列表，散列函數能夠把任意鍵轉換為 [0, M-1] 內的正整數，該正整數即為 hash 值。

散列表存在衝突，也就是兩個不同的鍵可能有相同的 hash 值。

散列函數應該滿足以下三個條件：

- 一致性：相等的鍵應當有相等的 hash 值，兩個鍵相等表示調用 equals() 返回的值相等。
- 高效性：計算應當簡便，有必要的話可以把 hash 值緩存起來，在調用 hash 函數時直接返回。
- 均勻性：所有鍵的 hash 值應當均勻地分佈到 [0, M-1] 之間，如果不能滿足這個條件，有可能產生很多衝突，從而導致散列表的性能下降。

除留餘數法可以將整數散列到 [0, M-1] 之間，例如一個正整數 k，計算 k%M 既可得到一個 [0, M-1] 之間的 hash 值。注意 M 必須是一個素數，否則無法利用鍵包含的所有信息。例如 M 為 10<sup>k</sup>，那麼只能利用鍵的後 k 位。

對於其它數，可以將其轉換成整數的形式，然後利用除留餘數法。例如對於浮點數，可以將其的二進制形式轉換成整數。

對於多部分組合的類型，每個部分都需要計算 hash 值，這些 hash 值都具有同等重要的地位。為了達到這個目的，可以將該類型看成 R 進制的整數，每個部分都具有不同的權值。

例如，字符串的散列函數實現如下：

```java
int hash = 0;
for (int i = 0; i < s.length(); i++)
    hash = (R * hash + s.charAt(i)) % M;
```

再比如，擁有多個成員的自定義類的哈希函數如下：

```java
int hash = (((day * R + month) % M) * R + year) % M;
```

R 通常取 31。

Java 中的 hashCode() 實現了哈希函數，但是默認使用對象的內存地址值。在使用 hashCode() 時，應當結合除留餘數法來使用。因為內存地址是 32 位整數，我們只需要 31 位的非負整數，因此應當屏蔽符號位之後再使用除留餘數法。

```java
int hash = (x.hashCode() & 0x7fffffff) % M;
```

使用 Java 的 HashMap 等自帶的哈希表實現時，只需要去實現 Key 類型的 hashCode() 函數即可。 Java 規定 hashCode() 能夠將鍵均勻分佈於所有的 32 位整數，Java 中的 String、Integer 等對象的 hashCode() 都能實現這一點。以下展示了自定義類型如何實現 hashCode()：

```java
public class Transaction {

    private final String who;
    private final Date when;
    private final double amount;

    public Transaction(String who, Date when, double amount) {
        this.who = who;
        this.when = when;
        this.amount = amount;
    }

    public int hashCode() {
        int hash = 17;
        int R = 31;
        hash = R * hash + who.hashCode();
        hash = R * hash + when.hashCode();
        hash = R * hash + ((Double) amount).hashCode();
        return hash;
    }
}
```

#### 3.4.2 基於拉鍊法的散列表

拉鍊法使用鍊錶來存儲 hash 值相同的鍵，從而解決衝突。

查找需要分兩步，首先查找 Key 所在的鍊錶，然後在鍊錶中順序查找。

對於N 個鍵，M 條鍊錶(N>M)，如果哈希函數能夠滿足均勻性的條件，每條鍊錶的大小趨向於N/M，因此未命中的查找和插入操作所需要的比較次數為\~N/M。

![](https://algs4.cs.princeton.edu/34hash/images/separate-chaining.png)

#### 3.4.3 基於線性探測法的散列表

![](https://algs4.cs.princeton.edu/34hash/images/linear-probing.png)

線性探測法使用空位來解決衝突，當衝突發生時，向前探測一個空位來存儲衝突的鍵。

使用線性探測法，數組的大小 M 應當大於鍵的個數 N（M>N)。

```java
public class LinearProbingHashST<Key, Value> implements UnorderedST<Key, Value> {

    private int N = 0;
    private int M = 16;
    private Key[] keys;
    private Value[] values;

    public LinearProbingHashST() {
        init();
    }

    public LinearProbingHashST(int M) {
        this.M = M;
        init();
    }

    private void init() {
        keys = (Key[]) new Object[M];
        values = (Value[]) new Object[M];
    }

    private int hash(Key key) {
        return (key.hashCode() & 0x7fffffff) % M;
    }
}
```

##### 3.4.3.1 查找

```java
public Value get(Key key) {
    for (int i = hash(key); keys[i] != null; i = (i + 1) % M)
        if (keys[i].equals(key))
            return values[i];

    return null;
}
```

##### 3.4.3.2 插入

```java
public void put(Key key, Value value) {
    resize();
    putInternal(key, value);
}

private void putInternal(Key key, Value value) {
    int i;
    for (i = hash(key); keys[i] != null; i = (i + 1) % M)
        if (keys[i].equals(key)) {
            values[i] = value;
            return;
        }

    keys[i] = key;
    values[i] = value;
    N++;
}
```

##### 3.4.3.3 刪除

刪除操作應當將右側所有相鄰的鍵值對重新插入散列表中。

```java
public void delete(Key key) {
    int i = hash(key);
    while (keys[i] != null && !key.equals(keys[i]))
        i = (i + 1) % M;

    // 不存在，直接返回
    if (keys[i] == null)
        return;

    keys[i] = null;
    values[i] = null;

    // 將之後相連的鍵值對重新插入
    i = (i + 1) % M;
    while (keys[i] != null) {
        Key keyToRedo = keys[i];
        Value valToRedo = values[i];
        keys[i] = null;
        values[i] = null;
        N--;
        putInternal(keyToRedo, valToRedo);
        i = (i + 1) % M;
    }
    N--;
    resize();
}
```

#### 3.4.4 調整數組大小

線性探測法的成本取決於連續條目的長度，連續條目也叫聚簇。當聚簇很長時，在查找和插入時也需要進行很多次探測。例如下圖中 2\~5 位置就是一個聚簇。

α = N/M，把 α 稱為使用率。理論證明，當 α 小於 1/2 時探測的預計次數只在 1.5 到 2.5 之間。為了保證散列表的性能，應當調整數組的大小，使得 α 在 [1/4, 1/2] 之間。

```java
private void resize() {
    if (N >= M / 2)
        resize(2 * M);
    else if (N <= M / 8)
        resize(M / 2);
}

private void resize(int cap) {
    LinearProbingHashST<Key, Value> t = new LinearProbingHashST<Key, Value>(cap);
    for (int i = 0; i < M; i++)
        if (keys[i] != null)
            t.putInternal(keys[i], values[i]);

    keys = t.keys;
    values = t.values;
    M = t.M;
}
```