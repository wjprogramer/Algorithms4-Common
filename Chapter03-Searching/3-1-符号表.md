### 3.1 符號表

**符號表**是一種存儲鍵值對的數據結構，目的是將一個鍵與一個值連接起來，支持兩種操作：

- **插入（put）**，即將一組新的鍵值對存入表中；
- **查找（get）**，即根據給定的鍵得到相應的值。

應用：

![](https://algs4.cs.princeton.edu/31elementary/images/symbol-table-applications.png)

#### 3.1.1 API

符號表分為有序和無序兩種，有序符號表主要指支持 min()、max() 等根據鍵的大小關係來實現的操作。

- 無序符號表

  ```java
  public interface UnorderedST<Key, Value> {
  
      int size();
  
      Value get(Key key);
  
      void put(Key key, Value value);
  
      void delete(Key key);
  }
  ```

  

  ![](https://algs4.cs.princeton.edu/31elementary/images/symbol-table-api.png)

- 有序符號表

  ```java
  public interface OrderedST<Key extends Comparable<Key>, Value> {
  
      int size();
  
      void put(Key key, Value value);
  
      Value get(Key key);
  
      Key min();
  
      Key max();
  
      int rank(Key key);
  
      List<Key> keys(Key l, Key h);
  }
  ```

  

  ![](https://algs4.cs.princeton.edu/31elementary/images/ordered-symbol-table-api.png)

**操作示例：**

![](https://algs4.cs.princeton.edu/31elementary/images/ordered-symbol-table-ops.png)

#### 3.1.3 用例

```java
public class FrequencyCounter {

    // Do not instantiate.
    private FrequencyCounter() { }

    public static void main(String[] args) {
        int distinct = 0, words = 0;
        int minlen = Integer.parseInt(args[0]);
        ST<String, Integer> st = new ST<String, Integer>();

        // compute frequency counts
        while (!StdIn.isEmpty()) {
            String key = StdIn.readString();
            if (key.length() < minlen) continue;
            words++;
            if (st.contains(key)) {
                st.put(key, st.get(key) + 1);
            }
            else {
                st.put(key, 1);
                distinct++;
            }
        }

        // find a key with the highest frequency count
        String max = "";
        st.put(max, 0);
        for (String word : st.keys()) {
            if (st.get(word) > st.get(max))
                max = word;
        }

        StdOut.println(max + " " + st.get(max));
        StdOut.println("distinct = " + distinct);
        StdOut.println("words = " + words);
    }
}
```

統計標準輸入中各個單詞出現的頻率，然後將最高頻率單詞打印出來。

#### 3.1.4 無序鍊錶的順序查找

![](https://algs4.cs.princeton.edu/31elementary/images/sequential-search.png)

```java
public class ListUnorderedST<Key, Value> implements UnorderedST<Key, Value> {

    private Node first;

    private class Node {
        Key key;
        Value value;
        Node next;

        Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    @Override
    public int size() {
        int cnt = 0;
        Node cur = first;
        while (cur != null) {
            cnt++;
            cur = cur.next;
        }
        return cnt;
    }

    @Override
    public void put(Key key, Value value) {
        Node cur = first;
        // 如果在鍊錶中找到節點的鍵等於 key 就更新這個節點的值為 value
        while (cur != null) {
            if (cur.key.equals(key)) {
                cur.value = value;
                return;
            }
            cur = cur.next;
        }
        // 否則使用頭插法插入一個新節點
        first = new Node(key, value, first);
    }

    @Override
    public void delete(Key key) {
        if (first == null)
            return;
        if (first.key.equals(key))
            first = first.next;
        Node pre = first, cur = first.next;
        while (cur != null) {
            if (cur.key.equals(key)) {
                pre.next = cur.next;
                return;
            }
            pre = pre.next;
            cur = cur.next;
        }
    }

    @Override
    public Value get(Key key) {
        Node cur = first;
        while (cur != null) {
            if (cur.key.equals(key))
                return cur.value;
            cur = cur.next;
        }
        return null;
    }
}
```
#### 3.1.5 有序數組的二分查找

使用一對平行數組，一個存儲鍵一個存儲值。

二分查找的 rank() 方法至關重要，當鍵在表中時，它能夠知道該鍵的位置；當鍵不在表中時，它也能知道在何處插入新鍵。

二分查找最多需要 logN+1 次比較，使用二分查找實現的符號表的查找操作所需要的時間最多是對數級別的。但是插入操作需要移動數組元素，是線性級別的。

![](https://algs4.cs.princeton.edu/31elementary/images/binary-search.png)

```java
public class BinarySearchOrderedST<Key extends Comparable<Key>, Value> implements OrderedST<Key, Value> {

    private Key[] keys;
    private Value[] values;
    private int N = 0;

    public BinarySearchOrderedST(int capacity) {
        keys = (Key[]) new Comparable[capacity];
        values = (Value[]) new Object[capacity];
    }

    @Override
    public int size() {
        return N;
    }

    @Override
    public int rank(Key key) {
        int l = 0, h = N - 1;
        while (l <= h) {
            int m = l + (h - l) / 2;
            int cmp = key.compareTo(keys[m]);
            if (cmp == 0)
                return m;
            else if (cmp < 0)
                h = m - 1;
            else
                l = m + 1;
        }
        return l;
    }

    @Override
    public List<Key> keys(Key l, Key h) {
        int index = rank(l);
        List<Key> list = new ArrayList<>();
        while (keys[index].compareTo(h) <= 0) {
            list.add(keys[index]);
            index++;
        }
        return list;
    }

    @Override
    public void put(Key key, Value value) {
        int index = rank(key);
        // 如果找到已經存在的節點鍵為 key，就更新這個節點的值為 value
        if (index < N && keys[index].compareTo(key) == 0) {
            values[index] = value;
            return;
        }
        // 否則在數組中插入新的節點，需要先將插入位置之後的元素都向後移動一個位置
        for (int j = N; j > index; j--) {
            keys[j] = keys[j - 1];
            values[j] = values[j - 1];
        }
        keys[index] = key;
        values[index] = value;
        N++;
    }

    @Override
    public Value get(Key key) {
        int index = rank(key);
        if (index < N && keys[index].compareTo(key) == 0)
            return values[index];
        return null;
    }

    @Override
    public Key min() {
        return keys[0];
    }

    @Override
    public Key max() {
        return keys[N - 1];
    }
}
```

##### 二分查找

**遞歸實現：**

```java
public int rank(Key key, int lo, int hi) {
    if (lo > hi) return lo;
   int mid = (lo + hi) / 2;
    int cmp = key.compareTo(key[mid]);
    if (cmp > 0) return rank(key, mid + 1, hi);
    else if (cmp < 0) return rank(key, lo, mid-1);
    else return mid;
}
```



**非遞歸實現：**

```java
public int rank(Key key) {
    int l = 0, h = N - 1;
    while (l <= h) {
        int m = l + (h - l) / 2;
        int cmp = key.compareTo(keys[m]);
        if (cmp == 0)
            return m;
        else if (cmp < 0)
            h = m - 1;
        else
            l = m + 1;
    }
    return l;
}
```



![](https://algs4.cs.princeton.edu/31elementary/images/rank.png)

#### 3.1.6 對二分查找的分析

在 N 個鍵的**有序數組**中進行二分查找最多需要 (lgN+1) 次比較（無論是否成功）。

向大小為N 的**有序數組**中插入一個新的元素在最壞情況下需要訪問~2N 次數組，因此向一個空符號表中插入N 個元素在最壞情況下需要訪問~N ^2 次數組。