---
title: 2019-02-01-algorithms4-2
abbrlink: afac
tags:
---

### 3.2 二叉查找樹

**二叉樹** 是一個空鏈接，或者是一個有左右兩個鏈接的節點，每個鏈接都指向一顆子二叉樹。

**二叉查找樹** （BST）是一顆二叉樹，並且每個節點的值都大於等於其左子樹中的所有節點的值而小於等於右子樹的所有節點的值。

![](https://algs4.cs.princeton.edu/32bst/images/binary-tree-anatomy.png)

![](https://algs4.cs.princeton.edu/32bst/images/bst-anatomy.png)

BST 有一個重要性質，就是它的中序遍歷結果遞增排序。

![](https://algs4.cs.princeton.edu/32bst/images/bst-subtree-count.png)

#### 3.2.1 基本實現

```java
public class BST<Key extends Comparable<Key>, Value> implements OrderedST<Key, Value> {

    protected Node root;

    protected class Node {
        Key key;
        Value val;
        Node left;
        Node right;
        // 以該節點為根的子樹節點總數
        int N;
        // 紅黑樹中使用
        boolean color;

        Node(Key key, Value val, int N) {
            this.key = key;
            this.val = val;
            this.N = N;
        }
    }

    @Override
    public int size() {
        return size(root);
    }

    private int size(Node x) {
        if (x == null)
            return 0;
        return x.N;
    }

    protected void recalculateSize(Node x) {
        x.N = size(x.left) + size(x.right) + 1;
    }
}
```

主要有查找、刪除、插入三個操作。

##### 3.2.1.1 查找(get)

- 如果樹是空的，則查找未命中；
- 如果被查找的鍵和根節點的鍵相等，查找命中；
- 否則遞歸地在子樹中查找：如果被查找的鍵較小就在左子樹中查找，較大就在右子樹中查找。

```java
public Value get(Key key) {
    return get(root, key);
}

private Value get(Node x, Key key) {
    // 在以 x 為根結點的子樹中查找並返回 key 所對應的值
    if(x == null)
        return null;
    int cmp = key.compareTo(x.key);
    if(cmp < 0)
        return get(x.left, key);
    else if(cmp > 0)
        return get(x.right, key);
    else
        return x.val;
}
```

![](https://algs4.cs.princeton.edu/32bst/images/bst-search.png)

##### 3.2.1.2 插入(put)

當插入的鍵不存在於樹中，需要創建一個新節點，並且更新上層節點的鏈接指向該節點，使得該節點正確地鏈接到樹中。

```java
public void put(Key key, Value val) {
    // 查找 key，找到則更新它的值，否則為它創建一個新的結點
    root = put(root, key, val);
}

private Node put(Node x, Key key, Value val) {
    // 如果 key 存在於以 x 為根結點的子樹中則更新它的值；
    // 否則將以 key 和 val 為鍵值對的新結點插入到該子​​樹中
    if(x == null)
        return new Node(key, val, 1);
    int cmp = key.compareTo(x.key);
    if(cmp < 0)
        x.left = put(x.left, key, val);
    else if(cmp > 0)
        x.right = put(x.right, key, val);
    else
        x.val = val;
    x.N = size(x.left) + size(x.right) + 1;
    return x;
}
```

![](https://algs4.cs.princeton.edu/32bst/images/bst-insert.png)



#### 3.2.2 分析

二叉查找樹的算法運行時間取決於樹的形狀，而樹的形狀又取決於鍵被插入的先後順序。

最好的情況下樹是完全平衡的，每條空鏈接和根節點的距離都為 logN。

![](https://algs4.cs.princeton.edu/32bst/images/bst-best.png)

在最壞的情況下，樹的高度為 N。

![](https://algs4.cs.princeton.edu/32bst/images/bst-worst.png)

#### 3.2.3 有序性相關的操作與刪除操作

##### 3.2.3.1 最大鍵與最小鍵

利用二叉平衡樹的有序性可以很快的用遞歸算法找到 min 與 max。

```java
public Key max() {
    return max(root).key;
}

private Node max(Node x) {
    if(x.right == null)
        return x;
    return min(x.right);
}

public Key min() {
    return min(root).key;
}

private Node min(Node x) {
    if(x.left == null)
        return x;
    return min(x.left);
}
```

##### 3.2.3.2 向上向下取整(floor)

```java
public Key floor(Key key) {
    Node x = floor(root, key);
    if(x == null)
        return null;
    return x.key;
}

private Node floor(Node x, Key key) {
    if(x == null)
        return null;
    int cmp = key.compareTo(x.key);
    if(cmp == 0)
        return x;
    if(cmp < 0)
        return floor(x.left, key);
    Node t = floor(x.right, key);
    if(t != null)
        return t;
    else
        return x;
}
```

![](https://algs4.cs.princeton.edu/32bst/images/bst-floor.png)

##### 3.2.3.3 排名(rank)

rank(key) 返回 key 的排名。

- 如果鍵和根節點的鍵相等，返回左子樹的節點數；
- 如果小於，遞歸計算在左子樹中的排名；
- 如果大於，遞歸計算在右子樹中的排名，加上左子樹的節點數，再加上 1（根節點）。

```java
@Override
public int rank(Key key) {
    return rank(key, root);
}

private int rank(Key key, Node x) {
    if (x == null)
        return 0;
    int cmp = key.compareTo(x.key);
    if (cmp == 0)
        return size(x.left);
    else if (cmp < 0)
        return rank(key, x.left);
    else
        return 1 + size(x.left) + rank(key, x.right);
}
```

##### 3.2.3.4 刪除最小鍵 deletemin()

二叉查找樹最難實現的就是 delete() 操作。

現看如何刪除最小鍵 deletemin()：

```java
public void deleteMin() {
    root = deleteMin(root);
}

private Node deleteMin(Node x) {
    if(x.left == null)
        return x.right;
    x.left = deleteMin(x.left);
    x.N = size(x.left) + size(x.right) + 1;
    return x;
}
```

![](https://algs4.cs.princeton.edu/32bst/images/bst-deletemin.png)

##### 3.2.3.5 刪除 delete()

再看刪除一般節點的情況，對於刪除一個擁有兩個子結點的情況，在刪除結點 x 後用它的**後繼結點**填補它的位置。因為 x 有一個右子結點，因此它的後繼結點就是**其右子樹中的最小結點**。這樣的替換仍然能保證樹的有序性，因為 x.key 和它的後繼結點的鍵之間不存在其他的鍵。

用 4 個簡單的步驟能夠完成將 x 替換為它的後繼結點的任務：

1. 將指向即將被刪除的結點的鏈接保存為 t；
2. 將 x 指向它的後繼結點`min(t.right)`；
3. 將x 的**右鏈接**（原本指向一棵所有結點都大於x.key 的二叉查找樹）指向`deleteMin(t.right)`，也就是在刪除後所有結點仍然大於x.key 的子二叉查找樹；
4. 將 x 的**左鏈接**（本為空）設為 t.left（其下所有的鍵都小於被刪除的結點和它的後繼結點）。

對於某些大規模的實際應用，這種方法可能會有一點性能上的問題。

```java
public void delete(Key key) {
    root = delete(root, key);
}

private Node delete(Node x, Key key) {
    if(x == null)
        return null;
    int cmp = key.compareTo(x.key);
    if(cmp < 0)
        x.left = delete(x.left, key);
    else if(cmp > 0)
        x.right = delete(x.right, key);
    else {
        if(x.right == null)
            return x.left;
        if(x.left == null)
            return x.right;
        Node t = x;
        x = min(t.right);
        x.right = deleteMin(t.right);
        x.left = t.left;
    }
    x.N = size(x.left) + size(x.right) + 1;
    return x;
}
```

![](https://algs4.cs.princeton.edu/32bst/images/bst-delete.png)

#### 3.2.6 範圍查找(Keys)

利用二叉查找樹中序遍歷的結果為遞增的特點。

```java
public Iterable<Key> keys() {
    return keys(min(), max());
}

public Iterable<Key> keys(Key lo, Key hi) {
    Queue<Key> queue = new Queue<Key>();
    keys(root, queue, lo, hi);
    return queue;
}

private void keys(Node x, Queue<Key> queue, Key lo, Key hi) {
    if(x == null)
        return;
    int cmplo = lo.compareTo(x.key);
    int cmphi = hi.compareTo(x.key);
    if(cmplo < 0)
        keys(x.left, queue, lo, hi);
    if(cmplo <= 0 && cmplo >= 0)
        queue.enqueue(x.key);
    if(cmphi > 0)
        keys(x.right, queue, lo, hi);
}
```

#### 分析

二叉查找樹所有操作在最壞的情況下所需要的時間都和樹的高度成正比。