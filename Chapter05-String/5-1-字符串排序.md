---
title: 2019-01-27-algorithms4-first
tags:
  - 算法
  - 讀書
---


## 5.1 字符串排序

### 5.1.1 鍵索引計數法

大致分為四個部分：

1. **計算出現頻率**

   選擇可代表該字符串的一個 key ，按照這個 key 將字符串按某種順序分組，計算各組中的字符串個數。

   例如：將字符串分為 0、1、2、3、4、5 個組 (key) ，最終完成之後數組 count[5] 中便存放有這五組類別中中字符串的個數。

   實現：(N為字符串個數)

   ```java
   for (int i = o; i < N; i++) {
       count[a[i].key() + 1] ++;
   }
   ```

   ![image-20190210152224482](assets/image-20190210152224482.png)

2. **將頻率轉化為索引**

   按分組後每個沒類別的個數計算出各個類別的起始索引。

   例如：第 0 組中有 5 個字符串，第 1 組中有 3 個字符串，可知第三組起始索引為 8 。

   實現：(R 位組個數)

   ```java
   for (int r = 0; r < R; r++) {
       count[r+1] = count[r]
   }
   ```

   ![image-20190210152305119](assets/image-20190210152305119.png)

3. **將元素分類**

   將元素按類別順序分類，即將屬於相應類別的字符串放入到該類別起始索引到下一類別起始索引之間。

   例如：判斷該字符串屬於第 1 組，將其放入第一組起始位置處，**並將該組起始索引 +1**。

   實現：

   ```java
   for (int i = 0; i < N; i++) {
       aux[count[a[i].key()]++] = a[i];
   }
   ```

   ![image-20190210152344377](assets/image-20190210152344377.png)

   ![image-20190210152409073](assets/image-20190210152409073.png)

4. **回寫**

   將排好序的字符串數組複製回原數組。

   ```java
   for (int i = 0; i < N; i++) {
       a[i] = aux[i];
   }
   ```

### 5.1.2 低位優先的字符串排序

以鍵索引計數法為基礎，將字符串數組進行多次排序。

書中以將若干個車牌號字符串排序為例，已知代表車牌號的字符串長度相同為 W ，則只需將車牌號進行 W 次排序。

![image-20190210152632750](assets/image-20190210152632750.png)

**鍵的選取：**即每次排序以何種手段將字符串分類，低位優先中的方法是將字符串左到右將每個字符看作key 分類排序，以此方法每次排序將會有一共R=256 個類別。

實現：

```java
public class LSD {
    public static void sort(String[] a, int w) {
        int N = a.length;
        int R = 256;
        String aux = new String[N];
        
        for (int d = w-1; d >= 0; d--) {
            // 根據第d個字符用鍵索引計數法排序
            int[] count = new int[R+1];
            for (int i = o; i < N; i++) { // 計算出現頻率
                count[a[i].charAt(d) + 1] ++;
            }
            for (int r = 0; r < R; r++) { // 將頻率轉化為索引
                count[r+1] = count[r]
            }
            for (int i = 0; i < N; i++) { // 將元素分類
                aux[count[a[i].charAt(d)]++] = a[i];
            }
for (int i = 0; i < N; i++) { //回寫
                a[i] = aux[i];
            }
        }
    }
}
```

完整代碼： [LSD.java](https://algs4.cs.princeton.edu/51radix/LSD.java.html)

![image-20190210152807218](assets/image-20190210152807218.png)

### 5.1.3 高位優先的字符串排序

```java
public class MSD {
    private static final int BITS_PER_BYTE =   8;
    private static final int BITS_PER_INT  =  32;   // each Java int is 32 bits 
    private static final int R             = 256;   // extended ASCII alphabet size
    private static final int CUTOFF        =  15;   // cutoff to insertion sort

    // do not instantiate
    private MSD() { } 

    public static void sort(String[] a) {
        int n = a.length;
        String[] aux = new String[n];
        sort(a, 0, n-1, 0, aux);
    }

    // return dth character of s, -1 if d = length of string
    private static int charAt(String s, int d) {
        assert d >= 0 && d <= s.length();
        if (d == s.length()) return -1;
        return s.charAt(d);
    }

    // sort from a[lo] to a[hi], starting at the dth character
    private static void sort(String[] a, int lo, int hi, int d, String[] aux) {

        // cutoff to insertion sort for small subarrays
        if (hi <= lo + CUTOFF) {
            insertion(a, lo, hi, d);
            return;
        }

        // compute frequency counts
        int[] count = new int[R+2];
        for (int i = lo; i <= hi; i++) {
            int c = charAt(a[i], d);
            count[c+2]++;
        }

        // transform counts to indicies
        for (int r = 0; r < R+1; r++)
            count[r+1] += count[r];

        // distribute
        for (int i = lo; i <= hi; i++) {
            int c = charAt(a[i], d);
            aux[count[c+1]++] = a[i];
        }

        // copy back
        for (int i = lo; i <= hi; i++) 
            a[i] = aux[i - lo];


        // recursively sort for each character (excludes sentinel -1)
        for (int r = 0; r < R; r++)
            sort(a, lo + count[r], lo + count[r+1] - 1, d+1, aux);
    }

    public static void sort(int[] a) {
        int n = a.length;
        int[] aux = new int[n];
        sort(a, 0, n-1, 0, aux);
    }

    // MSD sort from a[lo] to a[hi], starting at the dth byte
    private static void sort(int[] a, int lo, int hi, int d, int[] aux) {

        // cutoff to insertion sort for small subarrays
        if (hi <= lo + CUTOFF) {
            insertion(a, lo, hi, d);
            return;
        }

        // compute frequency counts (need R = 256)
        int[] count = new int[R+1];
        int mask = R - 1;   // 0xFF;
        int shift = BITS_PER_INT - BITS_PER_BYTE*d - BITS_PER_BYTE;
        for (int i = lo; i <= hi; i++) {
            int c = (a[i] >> shift) & mask;
            count[c + 1]++;
        }

        // transform counts to indicies
        for (int r = 0; r < R; r++)
            count[r+1] += count[r];

/************* BUGGGY CODE.
        // for most significant byte, 0x80-0xFF comes before 0x00-0x7F
        if (d == 0) {
            int shift1 = count[R] - count[R/2];
            int shift2 = count[R/2];
            for (int r = 0; r < R/2; r++)
                count[r] += shift1;
            for (int r = R/2; r < R; r++)
                count[r] -= shift2;
        }
************************************/
        // distribute
        for (int i = lo; i <= hi; i++) {
            int c = (a[i] >> shift) & mask;
            aux[count[c]++] = a[i];
        }

        // copy back
        for (int i = lo; i <= hi; i++) 
            a[i] = aux[i - lo];

        // no more bits
        if (d == 4) return;

        // recursively sort for each character
        if (count[0] > 0)
            sort(a, lo, lo + count[0] - 1, d+1, aux);
        for (int r = 0; r < R; r++)
            if (count[r+1] > count[r])
                sort(a, lo + count[r], lo + count[r+1] - 1, d+1, aux);
    }
}

```

完整代碼：[MSD.java](https://algs4.cs.princeton.edu/51radix/MSD.java.html)

![image-20190210155459946](assets/image-20190210155459946.png)